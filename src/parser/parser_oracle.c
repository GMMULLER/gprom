/*-----------------------------------------------------------------------------
 *
 * parser_oracle.c
 *			  
 *		
 *		AUTHOR: lord_pretzel
 *
 *		
 *
 *-----------------------------------------------------------------------------
 */

#include "common.h"
#include "log/logger.h"
#include "mem_manager/mem_mgr.h"
#include "parser/parser.h"
#include "parser/parse_internal.h"
#include "parser/parser_oracle.h"
#include "sql_parser.tab.h"
#include "instrumentation/timing_instrumentation.h"

static const char *languageHelp = "The user can specify a datalog program as a list of statements. "
        "A statement is either a rule, an answer predicate declaration, "
        "a regular path expression, or a provenance question.\n\n"
        "RULE: A rule is of the following form:\n"
        "\t\tQ(X1, ..., Xn) :- BODY .\n"
        "\twhere Q is an IDB predicate and each Xi is an expression over constants and variables from the body\n"
        "\tand BODY is a list of RELATIONAL ATOM and COMPARISON ATOM elements\n"
        "\tA RELATIONAL ATOM is of the form [NOT] R(Y1, ..., Yn) where R is an EDB or IDB predicate and each Yi is either a constant of a variable\n"
        "\tA COMPARISON ATOM is of the form X op Y WHERE X and Y are constants or variables and op is one of <,>,=,!=\n"
        ;

static Node *parseInternalOracle (void);

Node *
parseStreamOracle (FILE *stream)
{
    yyin = stream;

    return parseInternalOracle();
}

Node *
parseFromStringOracle (char *input)
{
    INFO_LOG("parse SQL:\n%s", input);
    setupStringInput(input);

    return parseInternalOracle();
}

const char *
languageHelpOracle (void)
{
    return languageHelp;
}

static Node *
parseInternalOracle (void) //TODO make copyObject work first
{
    START_TIMER("module - parser");

    NEW_AND_ACQUIRE_MEMCONTEXT("PARSER_CONTEXT");

    // parse
    int rc = yyparse();
    if (rc)
    {
        ERROR_LOG("parse error!");
        return NULL;
    }

    STOP_TIMER("module - parser");

    DEBUG_NODE_BEATIFY_LOG("query block model generated by parser is:",
            bisonParseResult);

    // create copy of parse result in parent context
    FREE_MEM_CONTEXT_AND_RETURN_COPY(Node,bisonParseResult);
}
